# EPOS-CAN

EPOS-CAN is a lightweight library for managing Maxon EPOS devices using Espressif microcontrollers with ESP-IDF and Arduino IDE. It allows interaction with PDO, SDO (upload and download), and NMT protocols. It features a serial console compatible with CiA 309-3 and includes numerous functionalities to make the interaction more user-friendly.

Although it is still a work in progress, we believe it has reached a quite useable state and therefore we are making it public.

## Hardware requirements

| Supported Targets | ESP32 | ESP32-C3 | ESP32-C6 | ESP32-H2 | ESP32-P4 | ESP32-S2 | ESP32-S3 |
| ----------------- | ----- | -------- | -------- | -------- | -------- | -------- | -------- |

* Espressif ESP32 dev module
* SN65HVD230 or equivalent transceiver
* Maxon EPOS Drive Controller

## Usage

* Add external dependency to your project. In ESP-IDF you may add `main/idf_component.yml` with the following:

```
version: "0.1.0"
description: "Your software"
url: "https://github.com/your-repo"

dependencies:
  epos:
    git: https://github.com/uclm-mantis/epos.git
```

* In Arduino IDE you may download [EPOS-CAN zip library](https://github.com/uclm-mantis/epos/archive/refs/heads/main.zip) and then "Add .ZIP library" in your Arduino IDE.

* Connect with your board using a Monitor. Sometimes the ESP-IDF builtin monitor on Windows is not recognized as an ANSI capable monitor and the console thread falls back to dumb mode. You may either press the reset button in the development board or use a different monitor application (such as *putty*).
* The console implements full line editing, completion and history using `linenoise`.

### Basic commands

The console is almost compatible with CiA 309 as implemented by CANopenNode. Please, note that we do not have direct access to CiA 309, we do not aim at a fully compliant implementation. Nonetheless, although we implement significant improvements over a basic CiA 309, the only known minor departure from CiA 309 has to do with negative numbers. See below.

The console has a builtin help system:

```
> help
Available commands:
  [[net] node] r[ead] <index> <subindex> [<datatype>]
  [[net] node] r[ead] <symbol> [<datatype>]
  [[net] node] w[rite] <index> <subindex> <datatype> <value>
  [[net] node] w[rite] <symbol> <value>
  [[net] node] start
  [[net] node] stop
  [[net] node] preop[erational]
  [[net] node] reset node|comm[unication]
  [net] set network|node|sdo_timeout|sdo_block <value>
  help [datatype|object|<symbol prefix>]
```

This help is not automatically generated by the argument parser library because we need to implement *net* and *node* handling by hand before they are passed to the actual command. Therefore it does not document extended commands.  In particular, the project comes with a WIP compatibility layer for a former library (FC) as an example of how a user may add a custom command set.

Although CiA 309 allows multiple CAN networks connected to the same controller, we are only using devices with a single TWAI peripheral. We are aware of the development of dual TWAI Espressif chips, but we haven't got one yet.

Unlike CANopenNode or similar CANopen implementations, we do not aim at producing a shadow copy of the object dictionary in the controller. You may, nonetheless, replicate as much as you want of the object dictionary using a somewhat standard callback mechanism.

Once started, EPOS are usually in *stopped* state, probably with some active faults.  The usual sequence to reset an EPOS2 to an operational state is:

```
set node 2
```

Sets target of the following commands to *id* number 2.  This is the identifier set in the dip switch of the EPOS.

```
> reset node
```

This triggers a transition to the *Initialisation* state. After a while the EPOS transitions automatically to a *Preoperational* state. In this precise moment an NMT booutup message is received.  You may see the trace in the console if tracing of events is active (it is active by default).

```
I (2624560) EPOS: Skip 00000702 (2 bytes) 00 00 00 00 00 00 00 00
```

COB-ID 0x702 signals an NMT heartbeat. Payload with a 0 means the EPOS is in *bootup* state. From now on the EPOS is able to handle SDO requests. Let us activate the device writing into the *control_word* object (`index=0x6040, subindex=0`).

```
> w control_word 0
```

In a fully compliant CiA console you would write `w 0x6040 0 u16 0`. This is not needed in EPOS-CAN because the console already knows the object dictionary of the EPOS device. Of course you may use the standard syntax and you may also use the help feature to find the right index, subindex and type of an object:

```
> help contr
Objects starting with contr:
  2220 00 u16 RW controller_structure
  6040 00 u16 RW control_word
```

Now let us complete the activation sequence:

```
> w control_word 6
> w control_word 7
> w control_word 0xf
```

Nothe that you may us the cursor *up* key to recall previous command and then edit that command to issue the new one.

If everything is right your EPOS will have a steady green led signaling it is ready.

From now on you will receive traces of PDO notifications from the EPOS.

Now you may issue the commands needed to operate the motor. For example, let us configure the motor in current mode:

```
> w modes_of_operation -- -3
```

Note the `--` before the `-3`. This is the only known departure from CiA 309. It is needed to communicate that no user options are added after that point. Therefore `-3` should not be interpreted as a flag but as a literal. You may also use `0xfd` if you want fully conformant interaction.

Now we may set the desired current:

```
> w current_mode_setting_value 500
```

And see the actual current value:

```
> r current_actual_value
```

And finally stop it:

```
> w current_mode_setting_value 0
```

### NMT programatic usage

### SDO programmatic usage

See `components/fc/*` as an example of API usage. For each object in the object dictionary you have a `setter` if it is writeable and a `getter` if it is readable.  Syntax of a setter is as follows:

```C
esp_err_t ec = set_control_word(n, 7);
```

First argument is the Node ID, second argument is the value to be set. The type of `value` is given in the object dictionary (see `components/epos/object_dictionary.h`). It should return `ESP_OK` if everything goes as expected.

A bitwise description of the types required for a given object is also available in `components/epos/epos_types.h`. For example, type `ControlWord_t` allows bit-level manipulation of the control word. The above example may also be written as:

```C
esp_err_t ec = set_control_word(n, (ControlWord_t){.enable_voltage = 1, .quickstop = 1, .switch_on = 1});
```

Getters are similar but second argument is a pointer to the location of the actual value.  For example, you may read the actual current value (in mA) as follows:

```C
int16_t current;
esp_err_t ec = get_current_actual_value(node, &current);
```

Sometimes you may also require bit-level manipulation of the return value. Use the types provided in `components/epos/epos_types.h` as follows:

```C
StatusWord_t status;
esp_err_t ec = get_status_word(n, (uint16_t*)&status);
if (status.target_reached) {
    // ...
}
```

SDO interaction is synchronous. If there is an ongoing SDO request while the running thread starts another SDO request then the running thread would block until a response is received for the ongoing SDO request.  There is a setable parameter `sdo_timeout` to adjust the maximum waiting time before a TIMEOUT error is returned.

### PDO, NMT heartbeats, EMCY

There are two ways to receive asynchronous notifications such as NMT heartbeats, PDO notifications or EMCY errors. The simplest interface is the synchronous interface.  Yoy may wait for a specific notification. For example, supose you are waiting for actual velocity updates from a periodic PDO with COB-ID 0x182 (0x180 + node ID).

```C
typedef struct __attribute__((packed)) {
    int32_t velocity;
    // ... remaining mapped objects
} PDO1_t;


for(;;) {
    PDO1_t pdo;
    esp_err_t ec = epos_wait_until(0x180 + n, &pdo);
    // use new pdo.velocity value
}
```

This is by far the easiest use case but sometimes you need to react to whatever notification it arrives and you may not be able to use one thread per COB-ID.  Then you can use a simple callback mechanism. For example, assume you will handle NMT heartbeat notifications in the same thread you wait for a PDO message:

```C
void my_heartbeat_handler(uint32_t cobid, void* msg, void* context)
{
    NMT_HB_state_t* state = (NMT_HB_state_t*) msg;
    uint8_t* current_state = (uint8_t*) context;
    *current_state = *state; 
}
```

Registering the callback is straightforward:

```C
uint8_t current_state;
epos_register_canopen_handler(0x700 + n, &my_heartbeat_handler, &current_state);
```

## Build from CANopen EDS

Although this project started as a library to support Maxon controllers programming from Espressif microcontrollers, it may also be used to build custom libraries to support other CANopen devices.

CANopen Electronic Data Sheet (EDS files, CiA 306-1) provide a full description of the capabilities of a device. You may use `eds_to_od.py` python script to extract the information from the EDS into a simple object dictionary table. Then, you may use `extract.py` python script to automatically generate an API customized for your device. 

## Acknowledgements

This project is partially funded by EU (Erasmus+ 2022-1-ES01- KA220-HED-000089155), JCCM and FEDER (SBPLY/21/180501/000238) and by NATO (SPS.MYP.G6001) research grants.

Developed by UCLM [Mantis Research Group](https://uclm-mantis.github.io/). 

Contact: [mantis@on.uclm.es](mailto:mantis@on.uclm.es).

### Collaborators:

* Fernando Castillo García
* Antonio González Rodríguez
* Sergio Juárez Pérez
* Andrea Martín Parra
* Francisco Moya Fernández

## Reference

* [CANopen CiA 301 (login required)](https://www.can-cia.org/cia-groups/technical-documents)
* [ESP32](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf)
* [SN65HVD230](https://www.ti.com/lit/ds/symlink/sn65hvd230.pdf)
* [EPOS2 Firmware Specification](https://www.maxongroup.es/medias/sys_master/root/8834321186846/EPOS2-Firmware-Specification-En.pdf)
